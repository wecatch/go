<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Go Tutorial</title>
  
  
  <link href="/go/atom.xml" rel="self"/>
  
  <link href="http://wecatch.me/go/"/>
  <updated>2017-12-30T00:30:37.882Z</updated>
  <id>http://wecatch.me/go/</id>
  
  <author>
    <name>wecatch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go goroutine 和 channel 详解 (一) ：介绍</title>
    <link href="http://wecatch.me/go//posts/go-goroutine-channel-1/"/>
    <id>http://wecatch.me/go//posts/go-goroutine-channel-1/</id>
    <published>2017-12-01T05:08:19.000Z</published>
    <updated>2017-12-30T00:30:37.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是阅读 “The Go Programming Language” 理解和记录。</p></blockquote><p>Go 支持两种方式的并发模型: communicating sequential processes(CSP) 和 shared memory multithreading，前者是 goroutine 和 channel 并发模型实现的基础，后者是传统的共享内存的方式，也就是多线程模型。</p><p>如何理解 CSP ？简单来说就是通过在不同的 goroutine 之间传递 value 来维护并发的下不同 goroutine 的状态，但是对变量的使用、修改要限制在单一的 goroutine 中。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在 Go 中可以并发执行的活动单元称之为 goroutine。当一个 Go 程序启动时，一个执行 main function 的 goroutine 会被创建，称之为 <code>main goroutine</code>。创建新的 goroutine 可以使用 go 语句，像这样: go f()，其中 <code>f</code> 是一个函数。使用 go 语句开启一个新的 goroutine 之后，go 语句之后的函数调用将在新的 goroutine 中执行，而不会阻塞当前的程序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        n = <span class="number">45</span></span><br><span class="line">    )</span><br><span class="line">    fibN := fib(n)</span><br><span class="line">    fmt.Printf(<span class="string">"\rFibonacci(%d) = %d\n"</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`_\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"\r%c"</span>, r)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>go spinner()</code> 和 <code>fib</code> 两个函数的执行是互不影响的，也就是说它们是两个可以同时执行。</p><h1 id="例子：并发的时钟-server"><a href="#例子：并发的时钟-server" class="headerlink" title="例子：并发的时钟 server"></a>例子：并发的时钟 server</h1><p>为了更好的演示 goroutine 在并发场景下的使用以及它带来的优势，我们一起来完成一个时钟 server，这个 server 非常简单，每次处理一个来自客户端的请求并把当前的时间格式化之后发回客户端， 我们先实现一个不支持 goroutine 的版本，即一次处理一个连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := io.WriteString(conn, time.Now().Format(<span class="string">"15:04:05\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在实现一个 client 来与 server 连接，client 只负责连接 server 并回显 server 的消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    mustCopy(os.Stdout, conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer, src io.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始我们的并发实验，首先执行 server 端程序，然后打开一个终端执行一个 client，可以看到 client 会不断输出当前的时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go run ch08_03_netcat1.go</span><br><span class="line">13:58:50</span><br><span class="line">13:58:51</span><br><span class="line">13:58:52</span><br><span class="line">13:58:53</span><br><span class="line">13:58:54</span><br><span class="line">13:58:55</span><br><span class="line">13:58:56</span><br><span class="line">13:58:57</span><br><span class="line">13:58:58</span><br></pre></td></tr></table></figure></p><p>然后我们再打开一个新的终端执行一个新的 client，发现没有任何输出，但是关闭第一个 client 之后，就会有时间输出。在这个例子中，由于 server 一次只能处理一个 client 的连接，所以当有多个 client 并发连接时，后续的 client 必须排队等候。</p><p>使用 goroutine 就可以提高 server 的并发处理能力从而解决这个问题，非常简单，只需要在 server 端处理连接的地方加一个go 关键字即可 <code>go handleConn(conn)</code>，启用新的 goroutine 之后，同时开启多个 client 都会有时间输出，server 有了并发处理的能力了。</p><h1 id="例子：echo-server"><a href="#例子：echo-server" class="headerlink" title="例子：echo server"></a>例子：echo server</h1><p>Echo server 是一个演示回声的例子，在这个例子中我们将向 server 发送一段消息，然后 server 会以回声的形式回显，比如发送 <code>Hello</code>，server 会回显 <code>HELLO</code>、<code>Hello</code> 和 <code>hello</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 连接不断读取数据并转化</span></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        echo(conn, input.Text(), <span class="number">1</span>*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(c, <span class="string">"\t"</span>, strings.ToUpper(shout))</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">"\t"</span>, shout)</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">"\t"</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中 server 在接收到 client 的连接之后开始读取 client 的数据并回显，回显的过程是间隔延迟一断时间执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="comment">// 从 conn 中读取数据并且送到标准输出</span></span><br><span class="line">    <span class="keyword">go</span> mustCopy(os.Stdout, conn)</span><br><span class="line">    <span class="comment">//从标准输入中读取数据并且送到 conn</span></span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer, src io.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123; <span class="comment">//check eof ctrl + d</span></span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client 代码很简单，从标准输入读取数据发送到 server 和从 server 读取数据发送到标准输出。</p><p>启动 server，启动一个 client 开启我们的实验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">± % make netcat2                                                               </span><br><span class="line">go run ch08_03_netcat2.go</span><br><span class="line">Hello</span><br><span class="line">     HELLO</span><br><span class="line">     Hello</span><br><span class="line">     hello</span><br><span class="line">Me</span><br><span class="line">     ME</span><br><span class="line">He   Me</span><br><span class="line">llo  me</span><br><span class="line"></span><br><span class="line">     HELLO</span><br><span class="line">     Hello</span><br><span class="line">     hello</span><br></pre></td></tr></table></figure><p>在现实世界的回声中，如果同时有多个回声存在应该会有交错出现的现象，但是我们的 client 有两个回声出现时不是交错出现，而是依次返回完一个才继续下一个，为了模拟真实的回声我们还需要一个 goroutine 用来实现回声的交错显现，像这样 <code>go echo(conn, input.Text(), 1*time.Second)</code>。</p><p><strong>Goroutine 的参数是在 go 语句执行之后确定的，所以 input.Text() 值是在 go 语句开启之后就确定的</strong>，也就是执行 go 语句时 input.Text() 如果返回消息 a，即使同一个 connection 后来又有消息 b，goroutine 函数的参数依然是 a，这样即使同一个 client 的 connection 会有多个 msg 也会按照我们的要求回显。</p><p>对于上面的 Go 程序来说，想要实现一个 server 同时处理多个 connection，而且甚至在同一个 connection 中实现并发需要的仅仅是两个简单的 go 关键字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列是阅读 “The Go Programming Language” 理解和记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go 支持两种方式的并发模型: communicating sequential processes(CSP) 和 s
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="goroutine" scheme="http://wecatch.me/go/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>Go goroutine 和 channel 详解 (二) ：channel</title>
    <link href="http://wecatch.me/go//posts/go-goroutine-channel-2/"/>
    <id>http://wecatch.me/go//posts/go-goroutine-channel-2/</id>
    <published>2017-12-01T05:08:19.000Z</published>
    <updated>2017-12-30T00:30:37.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果说 goroutine 是并发执行的一个 Go program， channel 就是它们之间的连接通道，它提供了 goroutine 之间相互通信的机制。Channel 是有类型的，channel 中使用的 type 称之为 element type，比如 int 类型的 channel 写作为 <code>chan int</code>。</p><p>Go 使用 make 内建函数创建 channel。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p><p>同 map 一样，一个 channel 引用着 make 创建的底层数据结构上，当把 channel 当做函数参数传递时，实际上是拷贝一份 reference，也就是说函数内部和外部引用的是相同的数据结构，所以在函数内部可以直接修改 channel 的值。同其它 reference type 一样，<strong>channel 的 zero value 是 nil</strong>。</p><p><strong>Channel 是可比较的，如果两个 channel 的类型相同，它们可以彼此相互比较</strong>，当然 channel 也可以和 nil 比较。</p><h1 id="基本操作-send、receive、close"><a href="#基本操作-send、receive、close" class="headerlink" title="基本操作: send、receive、close"></a>基本操作: send、receive、close</h1><p>Channel 有两种主要的操作：send 和 receive，综合来讲就是 communication。Go 使用 <code>&lt;-</code> 操作符来实现 send 和 receive。Send 操作 <code>&lt;-</code> 在 channel 右侧，receive 操作 <code>&lt;-</code> 在左侧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">//send</span></span><br><span class="line">x = &lt;- ch <span class="comment">//receive</span></span><br><span class="line">&lt;- ch <span class="comment">//receive</span></span><br></pre></td></tr></table></figure><p>Channel 还支持第三种操作 <code>close</code>，如果 channel 被 close，表明 channel 不会再 send 任何值了，如果还继续对 channel 执行 receive 操作，等 channel 中的值消耗完毕之后，之后返回的是对应 element type 的 zero value，如果对 channel 执行 send 操作，将会引起 panic。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></p><h1 id="Unbuffered-channel"><a href="#Unbuffered-channel" class="headerlink" title="Unbuffered channel"></a>Unbuffered channel</h1><p>在创建 channel 时可以指定 channel 的容量，如果不指定默认是 0，我们称这种 channel 是 unbuffered channel。</p><p>如果在一个 goroutine 中对 unbuffered channel 执行 send 操作将会一直阻塞，直到有另一个不同的 goroutine 对同样的 channel 开始执行 receive 为止，此时通过 channel send 的值会发送到接收端，之后两个 goroutine 才会各自继续执行。</p><p>相似地，如果是 receive 操作先执行，也是类似的过程。</p><p><strong>正是因为 unbuffered channel 的这种特性，unbuffered channel 也称之为 synchronous channel</strong>。</p><h1 id="Channel-实践之一：synchronous"><a href="#Channel-实践之一：synchronous" class="headerlink" title="Channel 实践之一：synchronous"></a>Channel 实践之一：synchronous</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        c &lt;- <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine finish "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码展示了利用 unbuffered channel 完成同步的能力，main goroutine 会一直等待直到满足特定条件时才会结束。</p><h1 id="Channel-的实践之二：pipeline"><a href="#Channel-的实践之二：pipeline" class="headerlink" title="Channel 的实践之二：pipeline"></a>Channel 的实践之二：pipeline</h1><p>Channel 是用来连接 goroutine 的通道，借此通道可以达到一个 goroutine 负责输入，另一个 goroutine 负责输出，这样的形式称之为 pipeline。</p><p><img src="http://ozoxs1p4r.bkt.clouddn.com/WX20171229-170322.png" alt="pipeline"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;如果说 goroutine 是并发执行的一个 Go program， channel 就是它们之间的连接通道，它提供了 goroutine 
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="goroutine" scheme="http://wecatch.me/go/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>Go interface 详解 (四) ：type assertion</title>
    <link href="http://wecatch.me/go//posts/go-interface-4/"/>
    <id>http://wecatch.me/go//posts/go-interface-4/</id>
    <published>2017-12-01T05:08:19.000Z</published>
    <updated>2017-12-09T06:42:04.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是阅读 “The Go Programming Language” 理解和记录。</p></blockquote><h2 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h2><p>Type assertion(断言)是用于 interface value 的一种操作，语法是 x.(T)，x 是 interface type 的表达式，而 T 是 assertd type，被断言的类型。</p><p>断言的使用主要有两种情景:<br>如果 asserted type 是一个 concrete type，一个实例类 type，断言会检查 x 的 dynamic type 是否和 T 相同，如果相同，断言的结果是 x 的 dynamic value，当然 dynamic value 的 type 就是 T 了。换句话说，对 concrete type 的断言实际上是获取 x 的 dynamic value。</p><p>如果 asserted type 是一个 interface type，断言的目的是为了检测 x 的 dynamic type 是否满足 T，如果满足，断言的结果是满足 T 的表达式，但是其 dynamic type 和 dynamic value 与 x 是一样的。换句话说，对 interface type 的断言实际上改变了 x 的 type，通常是一个更大 method set 的 interface type，但是保留原来的 dynamic type 和 dynamic value。</p><p>我们来看两个例子。</p><p><strong>case 1</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> w io.Writer</span><br><span class="line">    w = os.Stdout</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"hello Go!"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, w)</span><br><span class="line">    fw := w.(*os.File)</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, fw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，w 是一个有 <code>Write</code> method 的 interface expression，其 dynamic value 是 os.Stdout，断言 <code>w.(*os.File)</code> 针对 concrete type <code>*os.File</code> 进行的，那么 f 就是 w 的 dynamic value <code>os.Stdout</code>。</p><p><strong>case 2</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> w io.Writer</span><br><span class="line">    w = os.Stdout</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"hello Go!"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, w)</span><br><span class="line">    rw := w.(io.ReadWriter)</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, rw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 case 1, 断言 <code>w.(io.ReadWriter)</code> 针对 interface type <code>io.ReadWriter</code> 进行，那么 rw 是一个 dynamic value 为 <code>*os.File</code> 的 interface value。</p><p>不论是针对 concrete type 还是 Interface type 如果 assert expression 是 nil assert 都会失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fw := w.(*os.File) <span class="comment">//fail</span></span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">//fail</span></span><br></pre></td></tr></table></figure><p>通常我们仅仅只是想知道 dynamic value 是哪种 concrete type ，可以借助 ok 表达式。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File) <span class="comment">// success: ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure></p><p>在 ok 表达式中 nil 不会导致 assertion 失败，如果 assertion 成功 ok 是 true 否则是 false，另一个变量在 assertion 失败时是 asserted type 的 zero value。</p><p>OK 表达式经常用在 if 语句中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line"><span class="comment">// ...use f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Type-Switches"><a href="#Type-Switches" class="headerlink" title="Type Switches"></a>Type Switches</h2><p>Interface 一般被用在这两种场合，一种是像 io.Reader, io.Writer 那样，一个 interface 的 method 真正含义是表达了实现这个 interface 的不同 concrete type 的相似性，意味着这里充分发挥的是 interface method 的表现力。重点在 method，而不是 concrete type。</p><p>一种是利用 interface 可以存储不同 concrete type 的能力，在必要的时候根据不同的 concrete type 做不同的处理，这样的用法就是利用 interface 的 assertion 来判断 dynamic type 的类型来做出具体的判断。重点在 concrete type，而不是 method。</p><p>Type switch 就是利用 interface 存储不同 concrete type 的能力来实现的 assertion。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">uint</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种类型的语句叫 type switch，其中 x 是 interface expression，asserted type 是 type 字面量，每个 case 语句可以有一种或多种 types，nil case 匹配的是 x == nil 的情况，default case 匹配的是没有类型匹配的情况。</p><p>有时候在 type switch 中我们需要使用 dynamic value，这就需要 type assertion 可以提取 interface 的 dynamic value，同样有这样的语法可以支持这一操作 <code>switch x := x.(type){}</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> x2 <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> x3 <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> x4 <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(sqlQuote(x1))</span><br><span class="line">    fmt.Println(sqlQuote(x2))</span><br><span class="line">    fmt.Println(sqlQuote(x3))</span><br><span class="line">    fmt.Println(sqlQuote(x4))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">uint</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, x)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"true"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"false"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"no match case"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中被提取的 value 赋值给 x，这在 switch block 中会遮蔽断言表达式 x，但是不会影响 x 在 function 中的使用，因为 switch 和 for 一样也是 block scope。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列是阅读 “The Go Programming Language” 理解和记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Type-Assertion&quot;&gt;&lt;a href=&quot;#Type-Assertion&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="interface" scheme="http://wecatch.me/go/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go 常见错误之一：值拷贝和 for 循环中的单一变量</title>
    <link href="http://wecatch.me/go//posts/go-common-mistake-1/"/>
    <id>http://wecatch.me/go//posts/go-common-mistake-1/</id>
    <published>2017-10-24T04:47:05.000Z</published>
    <updated>2017-12-09T07:34:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 常见的错误一文中 <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="noopener">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a> 有这么一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 field slice 的类型改为 pointer 结果又不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码的差异究竟是如何导致结果的不同？</p><p>我对上面的代码 for 循环中的部分进行了一下改造，改造之后对应的代码分别是：</p><p>slice 是非指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">    pp := (*field).<span class="built_in">print</span></span><br><span class="line">    <span class="keyword">go</span> pp(&amp;v) <span class="comment">//非 pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> slice 是指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data := []*field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">    pp := (*field).<span class="built_in">print</span></span><br><span class="line">    <span class="keyword">go</span> pp(v) <span class="comment">// pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改造之后再去看原来的代码就能看出最明显的差异在 <code>print</code> 的这个 method 的 <code>receiver</code> 的传递上。</p><p>在 Go 中<strong>函数的调用是值拷贝 copy value</strong>，而且<strong>在 for 循环中 v 的变量始终是一个变量</strong>。</p><p>如果 v 是 pointer，print 这个 method 接收的是指针的拷贝，for 循环体中每次迭代 v 的 pointer value 都是不同的，所以输出不同。</p><p>如果 v 是一个普通的 struct，for 循环体中每次迭代 &amp;v 都是 v 这个变量本身的 pointer，也就是总是指向同一个 field，由于在很大程度上这段代码中的 goroutine 都是在 for 结束之后才执行，而此时 v 将会指向最后一个 field，也就是 <code>{&quot;three&quot;}</code>，所以输出相同。</p><p>有人说 one、two、three 的随机输出是因为 CPU 是多核的原因导致的，如果改成单核就是顺序输出，这样的说法并不是特别准确。理论上来讲 goroutine 的调度是有一定的随机性的，也就是即使是单核输出也有可能是随机的，只是在运行如此简单的例子时一般机器环境都不会导致这 3 个简单的 goroutine 出现交叉执行。比如可以在 print 输出之前模拟 io 繁忙的来达到即使是单核也可能是随机输出的目的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rand.Intn(<span class="number">100</span>) &gt; <span class="number">20</span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Go 常见的错误一文中 &lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dev
      
    
    </summary>
    
      <category term="practice" scheme="http://wecatch.me/go/categories/practice/"/>
    
    
      <category term="mistake" scheme="http://wecatch.me/go/tags/mistake/"/>
    
  </entry>
  
  <entry>
    <title>Go interface 详解 (三) ：interface 的值</title>
    <link href="http://wecatch.me/go//posts/go-interface-3/"/>
    <id>http://wecatch.me/go//posts/go-interface-3/</id>
    <published>2017-10-18T04:53:54.000Z</published>
    <updated>2017-12-09T07:34:56.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是阅读 “The Go Programming Language” 理解和记录。</p></blockquote><h1 id="Interface-value-的赋值"><a href="#Interface-value-的赋值" class="headerlink" title="Interface value 的赋值"></a>Interface value 的赋值</h1><p>从概念上来讲，interface value 有两部分组成：type 部分是一个 concrete type，vlaue 部分是这个 concrete type 对应的 instance，它们分别称之为 interface value 的 dynamic type 和 dynamic value。</p><p>由于 Go 是静态类型的语言，type 是在编译阶段已经定义好的，而 interface 存储的值是动态的，在上面这个概念模型中，type 部分更准确叫法是 type descriptors，主要是提供 concrete type 的相关信息，包括 method、name 等。</p><p>下面这几个语句：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>变量 <code>w</code> 依次存储了三种不同的值，在此我们依次来看看每种不同的值的确切含义。</p><p>语句 <code>var w io.Writer</code> 声明并初始化了一个 interface value <code>w</code>，其值是 <code>nil</code>，此时 type 和 value 部分都是 <code>nil</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w:</span><br><span class="line">    type --&gt; nil</span><br><span class="line">    value --&gt; nil</span><br></pre></td></tr></table></figure><p>interface value 是否是 nil 取决于其 dynamic type，在 nil 的 interface value 上调用会 panic<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// panic</span></span><br></pre></td></tr></table></figure></p><p>语句 <code>w = os.Stdout</code> 赋值 <code>*os.File</code> 类型的 value 给 w，这个赋值操作包含一个隐式的类型转换，用以把 concrete type 转换成 interface type <code>io.Writer(*os.File)</code>，在这个转换过程中 dynamic type 被赋值为 <code>*os.File</code> 类型，在这里其实是它的 type descriptor，同样得，dynamic value 赋值为 os.Stdout 的一份 copy，一个指向 <code>os.File</code> 类型的指针且代表<strong>标准输出</strong>的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w:</span><br><span class="line">    type --&gt; *os.File</span><br><span class="line">    value -------&gt; fd int=1(stdout)</span><br></pre></td></tr></table></figure></p><p>在 interface value w 上调用 <code>Write</code> method 实际上调用的是 <code>*os.File</code> 类型的 Write 方法，于是输出 “hello”。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></p><p>由于在编译阶段，我们并不知道一个 interface value 的 dynamic type 是什么，所以 interface value 的调用必须进行 dynamic dispatch。为了能调用 dynamic value 的 Write method，compiler 必须生成相关代码以便在执行的时候通过 dynamic type 获取对应 method 的真实地址的 copy，在调用的形式上好像是我们直接调用了 dynamic value 的 Write method。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></p><p>语句 <code>w=new(bytes.Buffer)</code> 赋值 <code>*bytes.Buffer</code> 类型的 value 作为 w 的 dynamic value，对 w 的处理是也类似的，调用 Write method 将调用 <code>*bytes.Buffer</code> 的 Write method。</p><p>语句 <code>w=nil</code> 和初始语句一样将 w 重置为 nil。</p><h1 id="Interface-value-的比较"><a href="#Interface-value-的比较" class="headerlink" title="Interface value 的比较"></a>Interface value 的比较</h1><p>Interface value 可以使用 <code>==</code> 和 <code>!=</code> 语句进行比较的。如果两个 interface value 的 dynamic type 相同，dynamic value 根据 dynamic type 的 <code>==</code> 比较操作是相等的，那么这两个 interface value 是相等的。因而 interface value 可以用在 map 中作为key 或者 switch 语句中。</p><p>虽然 interface value 本身是可以比较的，但是如果 dynamic type 不支持 compare 操作，那么对两个 dynamic type 相同的 interface value 比较将 panic，比如 slice。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure></p><p>所以使用时你应该总是留意，interface value 的 dynamic 是不是可以 compare 类型，不管 interface value 单独出现还是出现在其它类型中。</p><h1 id="格式化输出-interface-value"><a href="#格式化输出-interface-value" class="headerlink" title="格式化输出 interface value"></a>格式化输出 interface value</h1><p>Go 提供了格式化输出 interface value 的方法，方便在开发和调试中使用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, w) <span class="comment">// "&lt;nil&gt;"</span></span><br><span class="line"></span><br><span class="line">w=os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, w) <span class="comment">// "*os.File"</span></span><br><span class="line"></span><br><span class="line">w=<span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, w) <span class="comment">// "*bytes.Buffer"</span></span><br></pre></td></tr></table></figure></p><h1 id="警告：dynamic-value-是-nil-的-interface-value-并不是-nil"><a href="#警告：dynamic-value-是-nil-的-interface-value-并不是-nil" class="headerlink" title="警告：dynamic value 是 nil 的 interface value 并不是 nil"></a>警告：dynamic value 是 nil 的 interface value 并不是 nil</h1><p>Interface value 是 nil 和 interface value 包含的 dynamic value 是 nil 并不是一回事，<strong>后者不是 nil</strong>，这个潜在的区别给初学 Go 的 developer 造成了一定的困扰。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="keyword">byte</span>(<span class="string">"done!\n"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，函数 f 中将会出现 panic。由于对于 <code>*byte.Buffer</code> 时，当其值是 nil 时也满足 io.Writer 这个 interface，赋值给 out 之后，out 并不是 nil，但是调用 Write 方法时，Write 的 receiver 也就是 out 的 dynamic value 是 nil，因而会 panic。</p><p>解决方法是改变 main 中的 buf 为 io.Writer。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列是阅读 “The Go Programming Language” 理解和记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Interface-value-的赋值&quot;&gt;&lt;a href=&quot;#Interface-value-的赋值&quot; cl
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="interface" scheme="http://wecatch.me/go/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go interface 详解(二) ：定义和使用</title>
    <link href="http://wecatch.me/go//posts/go-interface-2/"/>
    <id>http://wecatch.me/go//posts/go-interface-2/</id>
    <published>2017-10-12T15:45:03.000Z</published>
    <updated>2017-12-09T07:34:51.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是阅读 “The Go Programming Language” 理解和记录。</p></blockquote><h1 id="定义-interface"><a href="#定义-interface" class="headerlink" title="定义 interface"></a>定义 interface</h1><p>正如上文所说，Go interface 是一种类型，一个 interface type 指定了一组 method 集合，如果说一个 concrete type 是一个 interface 的 instance，我们说这个 concrete type 实现了这个 interface 的所有方法。</p><p>在 Go 的标准库 <code>io</code> package 中定义了很多有用的 interface：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Reader</code> 代表任何可以去读 byte 的类型，类似的，<code>Writer</code> 代表任何可以写入 byte 的类型，<code>Closer</code> 代表任何可以执行 close 的类型。除此之外，我们还能在 io package 中发现其它<strong>组合式的 interface</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReaderWrite</code> 和 <code>ReadWriteCloser</code> 的语法形式和 struct 的 embedding 非常类似，被称为 <code>embedding interface</code>，通过这种形式可以便捷的实现一个新的 interface 而不必写出 interface 包含的所有 method。</p><p>注意 Go 标准库中对组合 interface 的命名，你应该总是遵循这样的规则。</p><p><code>ReaderWrite</code> 也可以用非 embedding 的形式实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者是二者的组合：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的几种实现都是等价的，但是我们更推崇使用 embedding 的形式。</p><p>说完了 interface type 的定义，再说说 interface type 使用。</p><h1 id="实现-interface-并使用"><a href="#实现-interface-并使用" class="headerlink" title="实现 interface 并使用"></a>实现 interface 并使用</h1><p>如果一个 concrete type 实现了某个 interface type，其值可以赋值给 interface type 的 instance。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(<span class="keyword">byte</span>.Buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwc io.ReadWriteCloser</span><br><span class="line">rwc = os.Stdout</span><br></pre></td></tr></table></figure></p><p>甚至赋值符号右边也可以是 interface instance，只要它们的关系满足<strong>左边 interface type method 集合是右边 interface type method 集合的子集</strong>即可：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = rwc</span><br></pre></td></tr></table></figure></p><p><code>w</code> method 集合 <code>{Writer}</code> 是 <code>rwc</code> method 集合 <code>{Reader, Writer, Closer}</code> 的子集。</p><p>在 Struct 中，在一个类型 T 上直接调用 receiver 是 <code>*T</code> 的 method 是合法的，只要 T 是以 variable 的形势存在，看个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样是可以的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">t.String()</span><br></pre></td></tr></table></figure></p><p>但是这样不行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&#123;&#125;.String()</span><br></pre></td></tr></table></figure></p><p>Struct 这个微妙的细节也体现在 interface 的赋值上，只有 <code>*T</code> 实现了 <code>String</code> 所以 <code>*T</code> 才能满足 interface <code>Stringer</code>，这样是可以的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ fmt.Stringer = &amp;t</span><br></pre></td></tr></table></figure></p><p>但是这样是不行的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T does not implement fmt.Stringer (String method has pointer)</span></span><br><span class="line"><span class="keyword">var</span> _ fmt.Stringer = t</span><br></pre></td></tr></table></figure></p><p>这也是<a href="http://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="noopener">理解 go interface 的 5 个关键点</a>第5点所讲到的。</p><p>虽然 interface type 和 concrete type 之间的关系是隐式的 implicitly，但是在某些情况下显式地声明 concrete type 和 interface 的关系则很有用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p><p><code>new(bytes.Buffer)</code> 返回 <code>bytes.Buffer</code> 的 pointer，这正是实现 <code>Writer</code> 需要的类型。</p><p>即使 <code>nil</code> 我们也可以显式地进行转换:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><h1 id="Empty-interface"><a href="#Empty-interface" class="headerlink" title="Empty interface"></a>Empty interface</h1><p>还有一种很重要的 interface 需要我们注意：<strong>interface{}</strong>，empty interface 没有任何 method。</p><p>Method 集合是 interface type 和 concrete type 之间关系的契约，也就是说 interface 向 concrete type 提出了要求说，你必须提供我要求的这些方法才能使用我，但是 empty interface 没有提供任何方法是不是不需要任何方法就可以使用它？的确如此。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p><p>Empty interface 可以让任何类型赋值，但是它没有任何方法该如何真正使用它？这就涉及到 type assertion ，从 <code>interface{}</code> 获取真正有用的 concrete value，后面我们会讲到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go interface 提供了在抽象层的组合和使用，只要你愿意你总是能找到一种方法可以在不修改已有包代码的情况下组合使用包中提供的任何功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列是阅读 “The Go Programming Language” 理解和记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;定义-interface&quot;&gt;&lt;a href=&quot;#定义-interface&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="interface" scheme="http://wecatch.me/go/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go interface 详解(一) ：介绍</title>
    <link href="http://wecatch.me/go//posts/go-interface-1/"/>
    <id>http://wecatch.me/go//posts/go-interface-1/</id>
    <published>2017-10-10T14:52:51.000Z</published>
    <updated>2017-12-09T07:34:47.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是阅读 “The Go Programming Language” 理解和记录。</p></blockquote><p>Go 中的 interface 是一种类型，更准确的说是一种抽象类型 abstract type，一个 interface 就是包含了一系列行为的 method 集合，interface 的定义很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中的 interface 不同于其它语言，它是隐式的 implicitly，这意味着对于一个已有类型，你可以不用更改任何代码就可以让其满足某个 interface。</p><p>如果一个 concrete type 实现了某个 interface，我们说这个 concrete type 实现了 interface 包含的所有 method，<strong>必须是所有的 method</strong>。</p><p>在 Go 的标准库 <code>fmt</code> 中有一系列的方法可以很好的诠释 interface 是如何应用到实践当中的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fprintf</code> 中的前缀 <code>F</code> 表示 <code>File</code>，意思是格式化的输出被输出到函数指定的第一个 <code>File</code> 类型的参数中。</p><p>在 <code>Printf</code> 函数中，调用 <code>Fprintf</code> 时指定的输出是标准输出，这正是 <code>Printf</code> 的功能：Printf formats according to a format specifier and writes to standard output，根据指定的格式化要求输出到标准输出，<code>os.Stdout</code> 的类型是 <code>*os.File</code> 。</p><p>同样在 <code>Sprintf</code> 函数中，调用 <code>Fprintf</code> 时指定的输出是一个指向某个 memory buffer 的指针，其类似一个 <code>*os.File</code>。</p><p>虽然 <code>bytes.Buffer</code> 和 <code>os.Stdout</code> 是不同的，但是它们都可以被用于调用同一个函数 <code>Fprintf</code>，就是因为 <code>Fprintf</code> 的第一个参数是接口类型 <code>io.Writer</code> ，而 <code>bytes.Buffer</code> 和 <code>os.Stdout</code> 都实现了这个 interface，即它们都实现了 <code>Write</code> 这个 method，这个 interface 并不是一个 <code>File</code> 却完成了类似 <code>File</code>的功能。</p><p><code>Fprintf</code> 其实并不关心它的第一个参数是一个 file 还是一段 memory，它只是调用了 <code>Write</code> method。这正是 interface 所关注的，<strong>只在乎行为，不在乎其值</strong>，这种能力让我们可以非常自由的向 <code>Fprintf</code> 传递任何满足 <code>io.Writer</code> 的 concrete type，这是 Go interface 带来的 <code>substitutability</code> 可替代性，object-oriented programming 的一种重要特性。</p><p>看个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteCounter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ByteCounter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    *c += ByteCounter(<span class="built_in">len</span>(p)) <span class="comment">// convert int to ByteCounter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c ByteCounter</span><br><span class="line">    c.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">    fmt.Println(c) <span class="comment">// 5  #1</span></span><br><span class="line">    fmt.Fprintf(&amp;c, <span class="string">"hello"</span>) #<span class="number">2</span> </span><br><span class="line">    fmt.Println(c) <span class="comment">// 10  #3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteCounter</code> 实现了 <code>Write</code> method，它满足 <code>io.Writer</code> interface，<code>Write</code> method 计算传给它的 byte slice 的长度并且赋值给自身，所以 <code>#1</code> 输出到标准输出的是它的值 5，正如前文所言，调用 <code>fmt.Fprintf</code> 时再次调用了 c 的 <code>Write</code> method，所以 <code>#3</code> 输出是 10。</p><p>这就是 Go 中的 interface 所具有的最基本的功能：作为一种 abstract type，实现各种 concrete type 的行为统一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列是阅读 “The Go Programming Language” 理解和记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go 中的 interface 是一种类型，更准确的说是一种抽象类型 abstract type，一个 interfa
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="interface" scheme="http://wecatch.me/go/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Go 中的面向对象</title>
    <link href="http://wecatch.me/go//posts/go-o-o/"/>
    <id>http://wecatch.me/go//posts/go-o-o/</id>
    <published>2017-08-17T05:26:18.000Z</published>
    <updated>2017-12-09T07:35:21.535Z</updated>
    
    <content type="html"><![CDATA[<p>Go 不是基于 class 的语言，但是 Go 提供了强大的类型系统来实现 OO（Object Oriented），关于如何正确使用 OO 的争论网上已经非常多了，在此我们秉承 Go 提供的面向对象机制来实现不同的例子和使用模式，借此了解 Go 中的 OO。</p><h2 id="使用-embed-type-实现继承"><a href="#使用-embed-type-实现继承" class="headerlink" title="使用 embed type 实现继承"></a>使用 embed type 实现继承</h2><p>Go 中的嵌入类型 <code>embed type</code> 本质上是一种 composition，Go 不像其它 OO 语言那样提供基于类的继承，那些继承体现的是 <code>is-a</code> 关系，但是 Go 不是。</p><p>Go 通过 embed type，可以实现 method 和 field 的复用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;name: <span class="string">"C"</span>&#125;</span><br><span class="line">    p.sayName() <span class="comment">// #1 C</span></span><br><span class="line"></span><br><span class="line">    s1 := Student&#123;name: <span class="string">"Java"</span>&#125;</span><br><span class="line">    s1.sayName() <span class="comment">// #2 此行输出空字符串</span></span><br><span class="line"></span><br><span class="line">    s2 := Student&#123;name: <span class="string">"Java"</span>, Person: Person&#123;name: <span class="string">"VB"</span>&#125;&#125;</span><br><span class="line">    s2.sayName()         <span class="comment">// #3 VB</span></span><br><span class="line">    fmt.Println(s2.name) <span class="comment">// #4 Java</span></span><br><span class="line">    fmt.Println(s2.Person.name) <span class="comment">//#5 VB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code> 是 <code>Student</code> 的 embed type，因而 Student 可以直接使用 Person 的 field 和 method，需要注意的是：</p><p>1.Student 中的同名属性可以遮蔽 embed type 的属性，<code>#4</code> 的输出<br>2.Student 虽然可以直接调用 embed type 的 method，但是 method 的 receiver 仍然是 embed type，所以 <code>#2</code> 输出为空。<br>3.直接通过 embed type 继承，embed type 无法获取被嵌入类型的属性，原因由 2 导致。</p><h2 id="类型组合的强大魔力"><a href="#类型组合的强大魔力" class="headerlink" title="类型组合的强大魔力"></a>类型组合的强大魔力</h2><p>Go 支持任意类型的 embed type，当然也包括 interface type，通过组合就可以实现多种不同行为的任意组合，这也是 Go 倡导<strong>以更小的单元实现你的代码功能，然后组合它们</strong>的理念。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// student 行为</span></span><br><span class="line"><span class="keyword">type</span> StudentTalk <span class="keyword">interface</span> &#123;</span><br><span class="line">    talk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// teacher 行为</span></span><br><span class="line"><span class="keyword">type</span> TeacherTalk <span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义两个 interface 用来表示不同的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// people 行为</span></span><br><span class="line"><span class="keyword">type</span> PeopleTalk <span class="keyword">interface</span> &#123;</span><br><span class="line">    StudentTalk</span><br><span class="line">    TeacherTalk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 embed type 把定义的两个 interface 组合为新的 interface <code>PeopleTalk</code>，此时 PeopleTalk 继承了两个 interface 的 method 集合，也就是 PeopleTalk 拥有了 StudentTalk 和 TeacherTalk 的 method 合集。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    TeacherTalk</span><br><span class="line">    StudentTalk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 也内嵌了 TeacherTalk 和 StudentTalk，对 Person 来说既可以理解成<strong>继承了两个 interface 的 method 集合</strong>，也可以理解是 Person 拥有<strong>两个类型为 TeacherTalk 和 StudentTalk 的 field</strong>，它们的分别可以被赋值为实现了它们的 struct 的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">talk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"student talk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"teacher say"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Struct Student 和 Teacher 分别实现了 StudentTalk 和 TeacherTalk。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">meet</span><span class="params">(p PeopleTalk)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"====&gt;people meet&lt;===="</span>)</span><br><span class="line">    meetTeacher(p)</span><br><span class="line">    meetStudent(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">meetTeacher</span><span class="params">(ps TeacherTalk)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"====&gt;teacher meet&lt;===="</span>)</span><br><span class="line">    ps.say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">meetStudent</span><span class="params">(ps StudentTalk)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"====&gt;student meet&lt;===="</span>)</span><br><span class="line">    ps.talk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    s := Student&#123;&#125;</span><br><span class="line">    <span class="comment">// Person 实现了 PeopleTalk 方法，通过 Teacher 和 Student 实例</span></span><br><span class="line">    p := Person&#123;TeacherTalk: &amp;t, StudentTalk: &amp;s&#125;</span><br><span class="line">    meet(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段 Go 代码展示了 interface 组合带来的魔力，meet function 的参数是 PeopleTalk，而 Person 的实例 p 由于通过实例 t 和 s 实现了 PeopleTalk 的 method，也就是说 p 可以直接通过 meet 函数传递，<strong>meet 的参数 PeopleTalk</strong>，而且实现了 PeopleTalk 必然实现了 StudentTalk 和 TeacherTalk，因为 PeopleTalk 是由它们组合而成的，进而可以在 meet 函数中可以直接调用 meetTeacher 和 meetStudent，它们各自的参数分别是 TeacherTalk 和 StudentTalk。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 不是基于 class 的语言，但是 Go 提供了强大的类型系统来实现 OO（Object Oriented），关于如何正确使用 OO 的争论网上已经非常多了，在此我们秉承 Go 提供的面向对象机制来实现不同的例子和使用模式，借此了解 Go 中的 OO。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="面向对象" scheme="http://wecatch.me/go/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>严格来说 Go 没有引用类型</title>
    <link href="http://wecatch.me/go//posts/go-no-reference-type/"/>
    <id>http://wecatch.me/go//posts/go-no-reference-type/</id>
    <published>2017-08-10T04:50:50.000Z</published>
    <updated>2017-12-09T07:35:17.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是引用类型"><a href="#什么是引用类型" class="headerlink" title="什么是引用类型"></a>什么是引用类型</h2><p>简单类说就是不同的变量内存地址是一样的，也就是说同一个内存地址有不同的别名。</p><p><strong>code-1</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = dd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4476836672</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(dd)</span><br><span class="line"><span class="number">4476836672</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p><code>code-1</code> 中的 Python 代码显示 c 和 dd 两个变量的内存地址都是一样的。</p><h2 id="Immutable-type-不是引用类型"><a href="#Immutable-type-不是引用类型" class="headerlink" title="Immutable type 不是引用类型"></a>Immutable type 不是引用类型</h2><p>Int，string，bool 这些 immutable 类型不会有引用类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    fmt.Println(&amp;a) <span class="comment">//0xc420072188</span></span><br><span class="line">    fmt.Println(&amp;b) <span class="comment">//0xc4200721b0</span></span><br><span class="line">    fmt.Println(&amp;c) <span class="comment">//0xc4200721b8</span></span><br><span class="line">    d := a</span><br><span class="line">    fmt.Println(&amp;d) <span class="comment">//0xc4200721d0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">"a"</span></span><br><span class="line">    fmt.Println(&amp;s) <span class="comment">//0x1040c108</span></span><br><span class="line">    s += <span class="string">"b"</span></span><br><span class="line">    fmt.Println(&amp;s) <span class="comment">//0x1040c108</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 a 赋值给 d ，d 和 a 的地址不同，字符串 s 二次赋值之后地址没有改变，在 immutable type 中不存在两个变量内存地址是一样的。</p><h2 id="Map-可以在函数内部改变，但是-map-不是引用类型"><a href="#Map-可以在函数内部改变，但是-map-不是引用类型" class="headerlink" title="Map 可以在函数内部改变，但是 map 不是引用类型"></a>Map 可以在函数内部改变，但是 map 不是引用类型</h2><p>Go 中函数传参是按值传递，在函数内部无法改变函数外部的值，但是 map 可以，是不是 map 是引用类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">"1"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    mm := m</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;m) <span class="comment">//0xc42002a028</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;mm) <span class="comment">//0xc42002a030</span></span><br><span class="line">    fmt.Println(m) <span class="comment">// map[0:0 1:1]</span></span><br><span class="line">    fmt.Println(mm) <span class="comment">//map[1:1 0:0]</span></span><br><span class="line">    changeMap(m)</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;m) <span class="comment">//0xc42002a028</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;mm)<span class="comment">//0xc42002a030</span></span><br><span class="line">    fmt.Println(m) <span class="comment">//map[2:2 0:0 1:1]</span></span><br><span class="line">    fmt.Println(mm) <span class="comment">//map[0:0 1:1 2:2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeMap</span><span class="params">(mmm <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mmm[<span class="number">2</span>] = <span class="string">"2"</span></span><br><span class="line">    fmt.Printf(<span class="string">"changeMap func %p\n"</span>, mmm) <span class="comment">//changeMap func 0xc420014150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以明确看到 main 中的 mm 和 m 地址完全不同，调用函数 changeMap 之后，它们的值都发生了改变，在函数 changeMap 内部，参数 mmm 的地址和 m 以及 mm 都不同，证实 map 并不是引用传参。</p><p>再一个例子。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">    makeMap(m)</span><br><span class="line">    fmt.Println(m == <span class="literal">nil</span>) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是引用传参 main 函数中的输出不应该是 true。</p><h2 id="Channel-也是按值传参"><a href="#Channel-也是按值传参" class="headerlink" title="Channel 也是按值传参"></a>Channel 也是按值传参</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;c1) <span class="comment">//0xc42002a038</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        changeChan(c1)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-c1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeChan</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"changeChan %p\n"</span>, &amp;c) <span class="comment">//0xc42002a040</span></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中的 channel 在函数内发生了值传递，但是函数内部和外部的 channel 地址不同。</p><h2 id="Map-不是引用类型，为什么可以在函数内部改变"><a href="#Map-不是引用类型，为什么可以在函数内部改变" class="headerlink" title="Map 不是引用类型，为什么可以在函数内部改变"></a>Map 不是引用类型，为什么可以在函数内部改变</h2><p>Go 源代码中显示 <a href="https://golang.org/src/runtime/hashmap.go" target="_blank" rel="noopener">https://golang.org/src/runtime/hashmap.go</a> map 底层是一个指向 hmap 的指针，这就可以解释即使函数传参是按值传递，由于传递的是指针的拷贝，指针指向的底层 hmap 并没有改变，所以可以在函数内部改变 map 。</p><blockquote><p>Go 中没有引用类型</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是引用类型&quot;&gt;&lt;a href=&quot;#什么是引用类型&quot; class=&quot;headerlink&quot; title=&quot;什么是引用类型&quot;&gt;&lt;/a&gt;什么是引用类型&lt;/h2&gt;&lt;p&gt;简单类说就是不同的变量内存地址是一样的，也就是说同一个内存地址有不同的别名。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="golang" scheme="http://wecatch.me/go/categories/golang/"/>
    
    
      <category term="引用类型" scheme="http://wecatch.me/go/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go channel 的基础特性</title>
    <link href="http://wecatch.me/go//posts/go-channel/"/>
    <id>http://wecatch.me/go//posts/go-channel/</id>
    <published>2017-08-03T14:17:33.000Z</published>
    <updated>2017-12-30T00:30:37.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此篇介绍 go channel</p></blockquote><h2 id="什么是-goroutine"><a href="#什么是-goroutine" class="headerlink" title="什么是 goroutine"></a>什么是 goroutine</h2><blockquote><p>They’re called goroutines because the existing terms — threads, coroutines, processes, and so on — convey inaccurate connotations. A goroutine has a simple model: it is a function executing in parallel with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p></blockquote><p>正如官方所言，goroutine 是一个轻量级的执行单元，相比线程开销更小，完全由 Go 语言负责调度，是 Go 支持并发的核心。开启一个 goroutine 非常简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> fmt.Println(<span class="string">"goroutine message"</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span>) <span class="comment">//1</span></span><br><span class="line">fmt.Println(<span class="string">"main function message"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>#1</code> 的代码是必须的，这是为了让新开启的 goroutine 有机会得到执行，开启一个 goroutine 之后，后续的代码会继续执行，在上面的例子中后续代码执行完毕程序就终止了，而开启的 goroutine 可能还没开始执行。</p><p>如果尝试去掉 <code>#1</code> 处的代码，程序也可能会正常运行，这是因为恰巧开启的 goroutine 只是简单的执行了一次输出，如果 goroutine 中耗时稍长就会导致只能看到主一句 <code>main function message</code> 。 </p><p>换句话话说，这里的 <code>time.sleep</code> 提供的是一种调度机制，这也是 Go 中 channel 存在的目的：负责消息传递和调度。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel 是 Go 中为 goroutine 提供的一种通信机制，借助于 channel 不同的 goroutine 之间可以相互通信。channel 是有类型的，而且有方向，可以把 channel 类比成 unix 中的 pipe。Go 通过 <code>&lt;-</code> 操作符来实现 channel 的写和读，send value <code>&lt;-</code> 在 channel 右侧，receive value <code>&lt;-</code> 在左侧，receive value 不赋值给任何变量是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)<span class="comment">//int 类型</span></span><br><span class="line">s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)<span class="comment">//字符串类型</span></span><br><span class="line">r := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)<span class="comment">//只读</span></span><br><span class="line">w := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- []<span class="keyword">int</span>)<span class="comment">//只写</span></span><br><span class="line">&lt;- w <span class="comment">//合法的语句</span></span><br></pre></td></tr></table></figure><p>Channel 最重要的作用就是传递消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"goroutine message"</span>)</span><br><span class="line">c &lt;- <span class="number">1</span> <span class="comment">//1</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-c <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"main function message"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中声明了一个 int 类型的 channel，在 goroutine 中在代码 <code>#1</code> 处向 channel 发送了数据 <code>1</code> ，在 main 中 <code>#2</code> 处等待数据的接收，如果 c 中没有数据，代码的执行将发生阻塞，直到有 goroutine 开始往 c 中 send value。</p><p>这是 channel 最简单的用法之一：同步，这种类型的 channel 容量是 0，称之为 <strong>unbuffered channel</strong>。</p><h2 id="unbuffered-channel"><a href="#unbuffered-channel" class="headerlink" title="unbuffered channel"></a>unbuffered channel</h2><p>Channel 可以设置容量，表示 channel 允许接收的消息个数，默认的 channel 容量是 0 称为 <strong>unbuffered channel</strong> ，对 unbuffered channel 执行 <strong>读</strong> 操作 value := &lt;-ch 会一直阻塞直到有数据可接收，执行 <strong>写</strong> 操作 ch &lt;- value 也会一直阻塞直到有 goroutine 对 channel 开始执行接收，正因为如此在同一个 goroutine 中使用 unbuffered channel 会造成 deadlock。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">&lt;-c</span><br><span class="line">fmt.Println(<span class="string">"main function message"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行报 <code>fatal error: all goroutines are asleep - deadlock!</code> ，读和写相互等待对方从而导致死锁发生。</p><p><img src="http://ozoxs1p4r.bkt.clouddn.com/Screen+Shot+2014-02-16+at+10.10.54+AM.jpg" alt="来自 www.goinggo.net"></p><h2 id="buffered-channel"><a href="#buffered-channel" class="headerlink" title="buffered channel"></a>buffered channel</h2><p>如果 channel 的容量不是 0，此类 channel 称之为 <strong>buffered channel</strong> ，buffered channel 在消息写入个数 <strong>未达到容量的上限之前不会阻塞</strong> ，一旦写入消息个数超过上限，下次输入将会阻塞，直到 channel 有位置可以再写入。</p><p><img src="http://ozoxs1p4r.bkt.clouddn.com/Screen+Shot+2014-02-17+at+8.38.15+AM.jpg" alt="来自 www.goinggo.net"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">fmt.Println(<span class="string">"write to c "</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"reading"</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子会输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">write to c <span class="number">0</span></span><br><span class="line">reading <span class="number">0</span></span><br><span class="line">write to c <span class="number">1</span></span><br><span class="line">reading <span class="number">1</span></span><br><span class="line">write to c <span class="number">2</span></span><br><span class="line">reading <span class="number">2</span></span><br><span class="line">write to c <span class="number">3</span></span><br><span class="line">reading <span class="number">3</span></span><br></pre></td></tr></table></figure><p>根据上文对 buffered channel 的解释，这个例子中 channel <code>c</code> 的容量是 3，在写入消息个数不超过 3 时不会阻塞，输出应该是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">write to c <span class="number">0</span></span><br><span class="line">write to c <span class="number">1</span></span><br><span class="line">write to c <span class="number">2</span></span><br><span class="line">reading <span class="number">0</span></span><br><span class="line">reading <span class="number">1</span></span><br><span class="line">reading <span class="number">2</span></span><br><span class="line">write to c <span class="number">3</span></span><br><span class="line">reading <span class="number">3</span></span><br></pre></td></tr></table></figure><p>问题在哪里？问题其实是在 <code>fmt.Println</code> ，一次输出就导致 goroutine 的执行发生了切换(相当于发生了 IO 阻塞)，因而即使 c 没有发生阻塞 goroutine 也会让出执行，一起来验证一下这个问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">num++</span><br><span class="line">v := <span class="string">"inner=&gt;"</span> + strconv.Itoa(num)</span><br><span class="line">s = <span class="built_in">append</span>(s, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">num++</span><br><span class="line">v := <span class="string">"outer=&gt;"</span> + strconv.Itoa(num)</span><br><span class="line">s = <span class="built_in">append</span>(s, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 slice 用来保存 c 进行写入和读取时的执行顺序，num 是用来标识执行顺序的，在没有加入 Println 之前，最终 s 是 [inner=&gt;1 inner=&gt;2 inner=&gt;3 inner=&gt;4 outer=&gt;5 outer=&gt;6 outer=&gt;7 outer=&gt;8] ，输出结果表明 c 达到容量上线之后才会发生阻塞。</p><p>相反有输出语句的版本结果则不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">num++</span><br><span class="line">v := <span class="string">"inner=&gt;"</span> + strconv.Itoa(num)</span><br><span class="line">s = <span class="built_in">append</span>(s, v)</span><br><span class="line">fmt.Println(<span class="string">"write to c "</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">num++</span><br><span class="line">v := <span class="string">"outer=&gt;"</span> + strconv.Itoa(num)</span><br><span class="line">s = <span class="built_in">append</span>(s, v)</span><br><span class="line">fmt.Println(<span class="string">"reading"</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[outer=&gt;1 inner=&gt;2 outer=&gt;3 inner=&gt;4 inner=&gt;5 inner=&gt;6 outer=&gt;7 outer=&gt;8] 输出结果能表明两个 goroutine 是交替执行，也就是说 IO 的调用 Println 导致 goroutine 的让出了执行。</p><h2 id="读取多个-channel-的消息"><a href="#读取多个-channel-的消息" class="headerlink" title="读取多个 channel 的消息"></a>读取多个 channel 的消息</h2><p>Go 提供了 select 语句来处理多个 channel 的消息读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c1 &lt;- <span class="string">"from 1"</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c2 &lt;- <span class="string">"from 2"</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select 语句可以从多个可读的 channel 中随机选取一个执行，注意是 <strong>随机选取。</strong> </p><h2 id="Channel-关闭之后"><a href="#Channel-关闭之后" class="headerlink" title="Channel 关闭之后"></a>Channel 关闭之后</h2><p>Channel 可以被关闭 <code>close</code> ，<strong>channel 关闭之后仍然可以读取</strong>，但是向被关闭的 channel send 会 panic。如果 channel 关闭之前有值写入，关闭之后将依次读取 channel 中的消息，读完完毕之后再次读取将会返回 channel 的类型的 zero value：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">c &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 1 2 3 0 0 0 ，0 是 int channel c 的 zero value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">c &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c 可以进行 range 迭代，如果 channel 没有被关闭 range 会一直等待 channel，但是关闭 channel 之后可以隐式的中断 range 的迭代</p><h2 id="判断-channel-的关闭"><a href="#判断-channel-的关闭" class="headerlink" title="判断 channel 的关闭"></a>判断 channel 的关闭</h2><p>Go 提供了 ok 表达式来判断 channel 的关闭状态。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok &lt;- c</span><br></pre></td></tr></table></figure></p><p>如果 channel 是关闭状态，ok 是 false，value 是 channel 的 zero value，否则 ok 是 true 表示 channel 未关闭，value 表示 channel 中的值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.miek.nl/go" target="_blank" rel="noopener">https://www.miek.nl/go</a></li><li><a href="http://guzalexander.com/2013/12/06/golang-channels-tutorial.html" target="_blank" rel="noopener">http://guzalexander.com/2013/12/06/golang-channels-tutorial.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;此篇介绍 go channel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-goroutine&quot;&gt;&lt;a href=&quot;#什么是-goroutine&quot; class=&quot;headerlink&quot; title=&quot;什么是 goroutine&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="channel" scheme="http://wecatch.me/go/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>新手 Go 程序员的最佳实践</title>
    <link href="http://wecatch.me/go//posts/go-new-programmer-best-practice/"/>
    <id>http://wecatch.me/go//posts/go-new-programmer-best-practice/</id>
    <published>2017-07-30T14:02:22.000Z</published>
    <updated>2017-12-09T07:35:10.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无意中在 medium 看到了一篇文章《Best practices for a new Go developer》，读完之后略有启发，摘录文章观点至此共飨，感兴趣读者可以直接阅读原文，原文很长也很散乱。</p></blockquote><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>工欲善其事必先利其器，真正写用 Go 编写代码之前先准备好你的环境，可以考虑从官方文档 <a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">How to Write Go Code</a>。</p><p>Go 提供了非常优秀的工具来保证代码的风格和质量，比如：gofmt，godoc，goimports，学会使用它们。</p><p>对于新手来说不要着急一开始就想要完整的 Go 程序，你应该认真熟悉 Go 的基本语义和特性，认真读完 官方的 <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effictive Go</a></p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>不要害怕犯错，对于一门新的语言，大家都是平等，即使是用 Go 写过一到两年程序的人也会犯一些低级的错误。</p><p>要学会顺势而为，学会用 Go 的方式去写 Go 的程序，比如要遵循 Go conventions，不要像 C 一样在 Go 中总是使用指针。</p><p>新手都应该看看这篇文章 <a href="http://talks.golang.org/2012/splash.article，它有助于你了解" target="_blank" rel="noopener">http://talks.golang.org/2012/splash.article，它有助于你了解</a> Go 是如何诞生的，它的哲学理念是什么。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>新手不要一开始就过渡关注 goroutine，channel 这些涉及并发的概念，你有可能滥用 channel 而不知道节制，毕竟 Go 在很多方面都表现的非常节制。</p><p>理解 interface，了解它的潜力，学会用组合和 interface 创建健壮的 Go 代码， 它是 Go 最富有天赋的能力之一。</p><p>如果你之前使用的其它 object-oriented 语言，暂时忘掉那些关于 OO 的特性和思维，虽然 Go 支持 OO，但 Go 不是基于类的语言，不支持类的继承。</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>Go 是强类型语言，意味着实现非常复杂的系统 API 时有可能会像 Java 或 C++ 一样使用大量的预定义类型，使代码变得脆弱丑陋，这并不是真正的 Go。Go 的 interface 和闭包特性允许我们写出更优雅更通用的实现。</p><p>学会高效的使用闭包，为此可以学习一些函数式编程语言的理论，或者学学 Ruby，可以看看 The Well-Grounded Rubyist 这本书，然后尝试在 Go 编程中尝试使用这些知识。</p><p>学会测试 Go 程序，学会使用 Go 相关的测试工具 unit testing，beachmarking testing，利用测试不断纠正和提高 Go 程序的质量，可以看看这个 <a href="http://github.com/feyeleanor/GoSpeed。" target="_blank" rel="noopener">http://github.com/feyeleanor/GoSpeed。</a></p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>不要强迫你把过去其它语言的经验带入 Go，每个语言都是不同的，如果你是第一次接触 Go，让自己用一个全新的视角去看待它，也就是你需要尝试从语言的创作者以及社区的角度去理解它。</p><p>一开始使用 Go，尽量避免使用 third party library，可能它们能简化你正在做的事情，但从长远角度来看，它们也妨碍了你对这么语言的理解。</p><p>从标准库中学习如何写出更好的 Go 代码，比如你可以从 <code>net/http</code> package 中学习如何使用 concurrency，也可以去看看  Rob Pike 关于 concurrency 的视频。</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>尝试使用 composition 而不是 inheritance，基于 OO 的 inheritance 的思维方式会妨碍你写出优雅的 Go 代码。</p><p>拥抱 interface。</p><p>并不是所有的都是 object。</p><blockquote><p>A language that doesn’t affect the way you think about programming, is not worth knowing. — Alan Perlis</p></blockquote><p>如果一门语言没有影响你对编程的思考，这么语言就不值得学习。</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><ul><li>保持函数短小，变量名不要太长</li><li>不要像写其它语言一样写 Go，Go 不是 Java，不是 Python，不是 Ruby。</li><li>花点时间搞懂 named and unnamed types。</li><li>学会构建完整的 Go project，并且发布它们。</li><li>Interface 很重要，你应该学会使用它们，很多你遇到的问题都可以用 interface 解决。</li><li>学习阅读源码是学习 Go 的一种极佳的方式。</li><li>保持简洁，简洁是 Go 的一个重要特性之一，避免过度工程化。</li><li>以更小的单元实现你的代码功能，然后组合它们。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这时间上有很多朴素的道理，很多人都知道，但是这些道理并没有给知道的人带来什么改变，比如勤奋不一定能成功，还是很多人很勤奋，有了好运气也不一定能成功，还是很多人天天盼望走狗屎运，前者太勤奋了，没有时间思考，后者不知道勤奋，总是抱有幻想。</p><p>学习语言也是一样，不要着急实践，要先想一想，看一看，看完之后不能太懒，还要动手练一练。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;无意中在 medium 看到了一篇文章《Best practices for a new Go developer》，读完之后略有启发，摘录文章观点至此共飨，感兴趣读者可以直接阅读原文，原文很长也很散乱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1
      
    
    </summary>
    
      <category term="practice" scheme="http://wecatch.me/go/categories/practice/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 类型系统</title>
    <link href="http://wecatch.me/go//posts/go-type/"/>
    <id>http://wecatch.me/go//posts/go-type/</id>
    <published>2017-07-27T11:57:17.000Z</published>
    <updated>2017-12-09T07:35:24.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="type-的分类"><a href="#type-的分类" class="headerlink" title="type 的分类"></a>type 的分类</h2><p>在 Go 中所有需要被定义和声明的对象都是 type：int，string，function，pointer，interface，map，struct 等等。</p><p>和大多数计算机语言一样，Go type 默认包含常用的基础数据类型，boolean，numeric and string，这些类型称为 <strong>pre-declarered types</strong>，这些基础的数据又可以进一步构成更复杂的类型 array，struct，map，slice，channel，func，interface 等被称之为 <strong>composite types</strong>。</p><p><strong>Composite types</strong> 由 <strong>pre-declared types</strong> 组成的复杂数据类型，常常由 type literal 构成。 </p><p>Type 可以是带名称和不带名称的，称之为 named type 和 unnamed type。</p><p><strong>Named Types</strong> 就是通过 type 关键字为一个已有的 type 起个别名，像这样 <code>type NewType ExistingType</code> NewType 就是名字。</p><p><strong>Pre-declared types</strong> 也是 <strong>named types</strong>。</p><p><strong>Unamed types</strong> 是一个 literal type，也就是没有名字，只有 type 本身，像这样 <code>[6]int</code> 没有名字。</p><p>每一个类型都有自己的 <strong>Underlying type</strong> ，如果 T 是 pre-declared type 或者 type literal，它们对应的 underlying type 就是自身 T，否则 T 的 underlying type 是 T 定义时引用的类型的 underlying type。</p><h2 id="underlying-type"><a href="#underlying-type" class="headerlink" title="underlying type"></a>underlying type</h2><p><strong>如果两个 type 都是 named type ，彼此之间不能相互赋值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewString <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> my <span class="keyword">string</span> =<span class="string">"a"</span></span><br><span class="line"><span class="keyword">var</span> you NewString = my <span class="comment">//cannot use my (type string) as type NewString in assignment</span></span><br></pre></td></tr></table></figure><p>虽然它们的 underlying type 都是 string，但 string 类型的 my 不能赋值给 NewString 类型的 you。</p><p><strong>如果两个 type 其中一个是 unamed type，彼此之间可以相互赋值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ptr *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> MapMap Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> mm Map</span><br><span class="line">    <span class="keyword">var</span> mmm MapMap</span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = mm</span><br><span class="line">    <span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = mmm</span><br><span class="line">    <span class="keyword">var</span> ptr Ptr = p</span><br><span class="line">    <span class="built_in">print</span>(ptr)</span><br><span class="line">    <span class="built_in">print</span>(m1)</span><br><span class="line">    <span class="built_in">print</span>(m2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么有这样的区分?</strong></p><p>如果为一个类型起了名字，说明你想要做区分，所以两个 named types 即使 underlying name 相同也是不能相互赋值的。</p><p>详见<a href="https://groups.google.com/forum/#!topic/golang-nuts/4Db2z2dEhfc" target="_blank" rel="noopener">Google Group Topic</a></p><h2 id="Named-type-和-Unamed-type"><a href="#Named-type-和-Unamed-type" class="headerlink" title="Named type 和 Unamed type"></a>Named type 和 Unamed type</h2><p>当 named types 被作为一个 function 的 receiver 时，它就拥有了自己的方法，unamed types 则不能，这是它们的重要区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm NewMap)</span> <span class="title">add</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    nm[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p NewMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">    p.add(<span class="number">10</span>, <span class="string">"a"</span>)</span><br><span class="line">    fmt.Println(p) <span class="comment">//map[10:a]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个一例外是是 pre-declare types 不能拥有自己的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">name</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n.name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会抛出 <strong>cannot define new methods on non-local type int</strong> 错误，不能对包之外的 type 定义方法，解决这个问题就是对 pre-declared types 重新定义别名。</p><h2 id="type-的属性继承一：直接继承"><a href="#type-的属性继承一：直接继承" class="headerlink" title="type 的属性继承一：直接继承"></a>type 的属性继承一：直接继承</h2><p>Declared named type 不会从它的 underlying type 或 existing type 继承 method，但是会继承 field。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am a person"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.Speak()</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    s.name = <span class="string">"jone"</span></span><br><span class="line">    fmt.Println(s.name)</span><br><span class="line">    <span class="comment">// s.Speak()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Named type Student 不会继承来自 Person Speak 的方法，打开注释执行报错 <strong>s.Speak undefined (type Student has no field or method Speak)</strong>，但是 Person 的 filed name 可以被 Student 继承。</p><blockquote><p>The declared type does not inherit any methods bound to the existing type, but the method set of an interface type or of elements of a composite type remains unchanged:</p></blockquote><p>But declared named type 例外的情况之一：<strong>如果 existing type 是 interface，它的 method set 会被继承</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    Talk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// existing type 是 I，I 是个接口，可以直接继承 I 的方法，II 等同于 I</span></span><br><span class="line"><span class="keyword">type</span> II I</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am a person"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Talk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am talking"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.Speak()</span><br><span class="line">    p.Talk()</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line">    i = &amp;p</span><br><span class="line">    i.Talk()</span><br><span class="line">    <span class="keyword">var</span> ii II</span><br><span class="line">    ii = &amp;p</span><br><span class="line">    ii.Talk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>II</code> 继承了 <code>I</code> 的 method，所以 Person 也实现了 II。</p><p>例外情况之二：如果 existing type 是 composite type，此情形根据官方所述没有看的很懂，希望有遇到之人可以交流一下。</p><h2 id="type-的属性继承二：type-embedding"><a href="#type-的属性继承二：type-embedding" class="headerlink" title="type 的属性继承二：type embedding"></a>type 的属性继承二：type embedding</h2><p>如果一个 type T‘ 被嵌入另一个 type T 作为它的 filed，T’ 的所有 field 和 method 都可以在 T 中使用，这种方法称之为 type embedding。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">    Talk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) Speak() &#123;</span><br><span class="line">    fmt.Println(&quot;I am a person&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) Talk() &#123;</span><br><span class="line">    fmt.Println(&quot;I am talking&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">    Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    var people People</span><br><span class="line">    people.name = &quot;people&quot;</span><br><span class="line">    people.Speak()</span><br><span class="line">    people.Talk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="type-转换"><a href="#type-转换" class="headerlink" title="type 转换"></a>type 转换</h2><p>Type 之间是可以相互转换的，但要遵循一定的转换规则，详细请看官方规范 <a href="https://golang.org/ref/spec#Conversions。" target="_blank" rel="noopener">https://golang.org/ref/spec#Conversions。</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p>文中部分代码</p><script src="//gist.github.com/7a0ed26a6700488073e629ba28a14397.js?file=go-type-inherit.go"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;type-的分类&quot;&gt;&lt;a href=&quot;#type-的分类&quot; class=&quot;headerlink&quot; title=&quot;type 的分类&quot;&gt;&lt;/a&gt;type 的分类&lt;/h2&gt;&lt;p&gt;在 Go 中所有需要被定义和声明的对象都是 type：int，string，function
      
    
    </summary>
    
      <category term="basic" scheme="http://wecatch.me/go/categories/basic/"/>
    
    
      <category term="type" scheme="http://wecatch.me/go/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>Go make 和 new 的区别</title>
    <link href="http://wecatch.me/go//posts/go-make-and-new/"/>
    <id>http://wecatch.me/go//posts/go-make-and-new/</id>
    <published>2017-07-25T22:12:23.000Z</published>
    <updated>2017-12-09T07:35:05.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>new 和 make 都可以用来分配空间，初始化类型，但是它们确有不同。</p></blockquote><h2 id="new-T-返回的是-T-的指针"><a href="#new-T-返回的是-T-的指针" class="headerlink" title="new(T) 返回的是 T 的指针"></a>new(T) 返回的是 T 的指针</h2><p>new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"p1 --&gt; %#v \n "</span>, p1) <span class="comment">//(*int)(0xc42000e250) </span></span><br><span class="line">fmt.Printf(<span class="string">"p1 point to --&gt; %#v \n "</span>, *p1) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">p2 = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">"p2 --&gt; %#v \n "</span>, p2) <span class="comment">//(*int)(0xc42000e278) </span></span><br><span class="line">fmt.Printf(<span class="string">"p2 point to --&gt; %#v \n "</span>, *p2) <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>上面的代码是等价的，new(int) 将分配的空间初始化为 int 的零值，也就是 0，并返回 int 的指针，这和直接声明指针并初始化的效果是相同的。</p><h2 id="make-只能用于-slice-map-channel"><a href="#make-只能用于-slice-map-channel" class="headerlink" title="make 只能用于 slice,map,channel"></a>make 只能用于 slice,map,channel</h2><p>make 只能用于 slice，map，channel 三种类型，make(T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> s1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"s1 is nil --&gt; %#v \n "</span>, s1) <span class="comment">// []int(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> s2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"s2 is nil --&gt; %#v \n "</span>, s2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"s2 is not nill --&gt; %#v \n "</span>, s2)<span class="comment">// []int&#123;0, 0, 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice 的零值是 nil，使用 make 之后 slice 是一个初始化的 slice，即 slice 的长度、容量、底层指向的 array 都被 make 完成初始化，此时 slice 内容被类型 int 的零值填充，形式是 [0 0 0]，map 和 channel 也是类似的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> m1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"m1 is nil --&gt; %#v \n "</span>, m1) <span class="comment">//map[int]string(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"m2 is nil --&gt; %#v \n "</span>, m2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"m2 is not nill --&gt; %#v \n "</span>, m2) <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> c1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c1 is nil --&gt; %#v \n "</span>, c1) <span class="comment">//(chan string)(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c2 is nil --&gt; %#v \n "</span>, c2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c2 is not nill --&gt; %#v \n "</span>, c2)<span class="comment">//(chan string)(0xc420016120)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-T-args-返回的是-T-的-引用"><a href="#make-T-args-返回的是-T-的-引用" class="headerlink" title="make(T, args) 返回的是 T 的 引用"></a>make(T, args) 返回的是 T 的 引用</h2><p>如果不特殊声明，go 的函数默认都是按值穿参，即通过函数传递的参数是值的副本，在函数内部对值修改不影响值的本身，但是 make(T, args) 返回的值通过函数传递参数之后可以直接修改，即 map，slice，channel 通过函数穿参之后在函数内部修改将影响函数外部的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, s2) <span class="comment">//[]int&#123;0, 0, 0&#125;</span></span><br><span class="line">modifySlice(s2)</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, s2) <span class="comment">//[]int&#123;1, 0, 0&#125;</span></span><br></pre></td></tr></table></figure><p>这说明 make(T, args) 返回的是引用类型，在函数内部可以直接更改原始值，对 map 和 channel 也是如此。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="string">"string"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyChan</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="string">"string"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"m2 is nil --&gt; %#v \n "</span>, m2) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"m2 is not nill --&gt; %#v \n "</span>, m2) <span class="comment">//map[int]string&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modifyMap(m2)</span><br><span class="line">fmt.Printf(<span class="string">"m2 is not nill --&gt; %#v \n "</span>, m2) <span class="comment">// map[int]string&#123;0:"string"&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c2 is nil --&gt; %#v \n "</span>, c2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c2 is not nill --&gt; %#v \n "</span>, c2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> modifyChan(c2)</span><br><span class="line">fmt.Printf(<span class="string">"c2 is not nill --&gt; %#v "</span>, &lt;-c2) <span class="comment">//"string"</span></span><br></pre></td></tr></table></figure><h2 id="很少需要使用-new"><a href="#很少需要使用-new" class="headerlink" title="很少需要使用 new"></a>很少需要使用 new</h2><p>以下代码演示了 <strong>struct 初始化的过程</strong>，可以说明不使用 new 一样可以完成 struct 的初始化工作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明初始化</span></span><br><span class="line"><span class="keyword">var</span> foo1 Foo</span><br><span class="line">fmt.Printf(<span class="string">"foo1 --&gt; %#v\n "</span>, foo1) <span class="comment">//main.Foo&#123;age:0, name:""&#125;</span></span><br><span class="line">foo1.age = <span class="number">1</span></span><br><span class="line">fmt.Println(foo1.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct literal 初始化</span></span><br><span class="line">foo2 := Foo&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo2 --&gt; %#v\n "</span>, foo2) <span class="comment">//main.Foo&#123;age:0, name:""&#125;</span></span><br><span class="line">foo2.age = <span class="number">2</span></span><br><span class="line">fmt.Println(foo2.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针初始化</span></span><br><span class="line">foo3 := &amp;Foo&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo3 --&gt; %#v\n "</span>, foo3) <span class="comment">//&amp;main.Foo&#123;age:0, name:""&#125;</span></span><br><span class="line">foo3.age = <span class="number">3</span></span><br><span class="line">fmt.Println(foo3.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 初始化</span></span><br><span class="line">foo4 := <span class="built_in">new</span>(Foo)</span><br><span class="line">fmt.Printf(<span class="string">"foo4 --&gt; %#v\n "</span>, foo4) <span class="comment">//&amp;main.Foo&#123;age:0, name:""&#125;</span></span><br><span class="line">foo4.age = <span class="number">4</span></span><br><span class="line">fmt.Println(foo4.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针并用 new 初始化</span></span><br><span class="line"><span class="keyword">var</span> foo5 *Foo = <span class="built_in">new</span>(Foo)</span><br><span class="line">fmt.Printf(<span class="string">"foo5 --&gt; %#v\n "</span>, foo5) <span class="comment">//&amp;main.Foo&#123;age:0, name:""&#125;</span></span><br><span class="line">foo5.age = <span class="number">5</span></span><br><span class="line">fmt.Println(foo5.age)</span><br></pre></td></tr></table></figure></p><p>foo1 和 foo2 是同样的类型，都是 Foo 类型的值，foo1 是通过 var 声明，Foo 的 filed 自动初始化为每个类型的零值，foo2 是通过字面量的完成初始化。</p><p>foo3，foo4 和 foo5 是一样的类型，都是 Foo 的指针 *Foo。</p><p><strong>但是所有 foo 都可以直接使用 Foo 的 filed，读取或修改，为什么？</strong></p><p>如果 x 是可寻址的，&amp;x 的 filed 集合包含 m，x.m 和 (&amp;x).m 是等同的，go 自动做转换，也就是 foo1.age 和 foo3.age 调用是等价的，go 在下面自动做了转换。</p><p>因而可以直接使用 struct literal 的方式创建对象，能达到和 new 创建是一样的情况而不需要使用 new。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>new(T) 返回 T 的指针 *T 并指向 T 的零值。<br>make(T) 返回的初始化的 T，只能用于 slice，map，channel。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;new 和 make 都可以用来分配空间，初始化类型，但是它们确有不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;new-T-返回的是-T-的指针&quot;&gt;&lt;a href=&quot;#new-T-返回的是-T-的指针&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="basic" scheme="http://wecatch.me/go/categories/basic/"/>
    
    
      <category term="make" scheme="http://wecatch.me/go/tags/make/"/>
    
      <category term="new" scheme="http://wecatch.me/go/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>Go defer 的关键特性解读和示例</title>
    <link href="http://wecatch.me/go//posts/go-defer/"/>
    <id>http://wecatch.me/go//posts/go-defer/</id>
    <published>2017-07-23T14:17:33.000Z</published>
    <updated>2017-12-09T07:34:43.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defer-的作用和执行时机"><a href="#defer-的作用和执行时机" class="headerlink" title="defer 的作用和执行时机"></a>defer 的作用和执行时机</h2><p>go 的 defer 语句是用来<strong>延迟执行函数的</strong>，而且延迟发生在<strong>调用函数 return 之后</strong>，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> b()</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 的执行是发生在 return 0 之后，注意 defer 的语法，关键字 defer 之后是函数的调用。</p><h2 id="defer-的重要用途一：清理释放资源"><a href="#defer-的重要用途一：清理释放资源" class="headerlink" title="defer 的重要用途一：清理释放资源"></a>defer 的重要用途一：清理释放资源</h2><p>由于 defer 的延迟特性，defer 常用在函数调用结束之后清理相关的资源，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br></pre></td></tr></table></figure><p>文件资源的释放会在函数调用结束之后借助 defer 自动执行，不需要时刻记住哪里的资源需要释放，打开和释放必须相对应。</p><p>用一个例子深刻诠释一下 defer 带来的便利和简洁。</p><p>代码的主要目的是打开一个文件，然后复制内容到另一个新的文件中，没有 defer 时这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    if err != nil &#123; //1</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    written, err = io.Copy(dst, src)</span><br><span class="line">    dst.Close()</span><br><span class="line">    src.Close()</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码在 <code>#1</code> 处返回之后，src 文件没有执行关闭操作，可能会导致资源不能正确释放，改用 defer 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer dst.Close()</span><br><span class="line"></span><br><span class="line">    return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src 和 dst 都能及时清理和释放，无论 return 在什么地方执行。</p><p>鉴于 defer 的这种作用，defer 常用来释放数据库连接，文件打开句柄等释放资源的操作。</p><h2 id="defer-的重要用途二：执行-recover"><a href="#defer-的重要用途二：执行-recover" class="headerlink" title="defer 的重要用途二：执行 recover"></a>defer 的重要用途二：执行 recover</h2><p>被 defer 的函数在 return 之后执行，这个时机点正好可以捕获函数抛出的 panic，因而 defer 的另一个重要用途就是执行 recover。</p><p>recover 只有在 defer 中使用才更有意义，如果在其他地方使用，由于 program 已经调用结束而提前返回而无法有效捕捉错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ok := <span class="built_in">recover</span>(); ok != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"recover"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"error"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住 defer 要放在 panic 执行之前。</p><h2 id="多个-defer-的执行顺序"><a href="#多个-defer-的执行顺序" class="headerlink" title="多个 defer 的执行顺序"></a>多个 defer 的执行顺序</h2><p>defer 的作用就是把关键字之后的函数执行压入一个栈中延迟执行，多个 defer 的执行顺序是后进先出 LIFO ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"1"</span>) &#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"2"</span>) &#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"3"</span>) &#125;()</span><br></pre></td></tr></table></figure><p>输出顺序是 321。</p><p>这个特性可以对一个 array 实现逆序操作。</p><h2 id="被-deferred-函数的参数在-defer-时确定"><a href="#被-deferred-函数的参数在-defer-时确定" class="headerlink" title="被 deferred 函数的参数在 defer 时确定"></a>被 deferred 函数的参数在 defer 时确定</h2><p>这是 defer 的特点，一个函数被 defer 时，它的参数在 defer 时进行计算确定，即使 defer 之后参数发生修改，对已经 defer 的函数没有影响，什么意思？看例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 执行输出的是 0 而不是 1，因为 defer 时，i 的值是 0，此时被 defer 的函数参数已经进行执行计算并确定了。</p><p>再看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := a + b</span><br><span class="line">    fmt.Println(index, a, b, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> calc(<span class="string">"1"</span>, a, calc(<span class="string">"10"</span>, a, b))</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码输出 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 1 2 3 </span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure><p>defer 函数的参数 第三个参数在 defer 时就已经计算完成并确定，第二个参数 a 也是如此，无论之后 a 变量是否修改都不影响。</p><h2 id="被-defer-的函数可以读取和修改带名称的返回值"><a href="#被-defer-的函数可以读取和修改带名称的返回值" class="headerlink" title="被 defer 的函数可以读取和修改带名称的返回值"></a>被 defer 的函数可以读取和修改带名称的返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被 defer 的函数是在 return 之后执行，可以修改带名称的返回值，上面的函数 c 返回的是 2。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">https://blog.golang.org/defer-panic-and-recover</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;defer-的作用和执行时机&quot;&gt;&lt;a href=&quot;#defer-的作用和执行时机&quot; class=&quot;headerlink&quot; title=&quot;defer 的作用和执行时机&quot;&gt;&lt;/a&gt;defer 的作用和执行时机&lt;/h2&gt;&lt;p&gt;go 的 defer 语句是用来&lt;stron
      
    
    </summary>
    
      <category term="advanced" scheme="http://wecatch.me/go/categories/advanced/"/>
    
    
      <category term="defer" scheme="http://wecatch.me/go/tags/defer/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 golang nil</title>
    <link href="http://wecatch.me/go//posts/go-nil/"/>
    <id>http://wecatch.me/go//posts/go-nil/</id>
    <published>2017-06-11T12:01:41.000Z</published>
    <updated>2017-12-09T07:35:14.584Z</updated>
    
    <content type="html"><![CDATA[<p>golang 中的 nil 是不同于其他语言的，为了更好的理解 nil，在此我将尝试一步一步揭示 nil 在 golang 中的一些操作和现象。</p><h2 id="1-nil-是不能比较的"><a href="#1-nil-是不能比较的" class="headerlink" title="1. nil 是不能比较的"></a>1. nil 是不能比较的</h2><p><strong>code-1</strong> <a href="https://play.golang.org/p/FM7oW794sU" target="_blank" rel="noopener">Play</a> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="literal">nil</span>==<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-1 输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp/sandbox318449491/main.go:8: invalid operation: nil == nil (operator == not defined on nil)</span><br></pre></td></tr></table></figure><p>这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">None</span> == <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>从 go 的输出结果不难看出，<code>==</code> 对于 nil 来说是一种未定义的操作。</p><h2 id="2-默认-nil-是-typed-的"><a href="#2-默认-nil-是-typed-的" class="headerlink" title="2. 默认 nil 是 typed 的"></a>2. 默认 nil 是 typed 的</h2><p><strong>code-2</strong> <a href="https://play.golang.org/p/PVGa9tCWSs" target="_blank" rel="noopener">Play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%T"</span>, <span class="literal">nil</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-2 输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp/sandbox379579345/main.go:9: use of untyped nil</span><br></pre></td></tr></table></figure><p>print 的输出时未指定类型的，因而无法输出</p><h2 id="3-不同类型-nil-的-address-是一样的"><a href="#3-不同类型-nil-的-address-是一样的" class="headerlink" title="3. 不同类型 nil 的 address 是一样的"></a>3. 不同类型 nil 的 address 是一样的</h2><p><strong>code-3</strong> <a href="https://play.golang.org/p/YQkFQx1hPi" target="_blank" rel="noopener">Play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, m)</span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m 和 ptr 的 address 都是 0x0</p><h2 id="4-不同类型的-nil-是不能比较的"><a href="#4-不同类型的-nil-是不能比较的" class="headerlink" title="4. 不同类型的 nil 是不能比较的"></a>4. 不同类型的 nil 是不能比较的</h2><p>   <strong>code-4</strong> <a href="https://play.golang.org/p/20q0oe2Iu5" target="_blank" rel="noopener">Play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">fmt.Printf(m == ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-4 输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp/sandbox618627491/main.go:10: invalid operation: m == ptr (mismatched types map[int]string and *int)</span><br></pre></td></tr></table></figure><h2 id="5-nil-是-map，slice，pointer，channel，func，interface-的零值"><a href="#5-nil-是-map，slice，pointer，channel，func，interface-的零值" class="headerlink" title="5. nil 是 map，slice，pointer，channel，func，interface 的零值"></a>5. nil 是 map，slice，pointer，channel，func，interface 的零值</h2><p><strong>code-5</strong> <a href="https://play.golang.org/p/VeDuWMU4QR" target="_blank" rel="noopener">Play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> sl []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">i</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, m)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, ptr)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, sl)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code-5 输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map[int]string(nil)</span><br><span class="line">(*int)(nil)</span><br><span class="line">(chan int)(nil)</span><br><span class="line">[]int(nil)</span><br><span class="line">(func())(nil)</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure><p><a href="https://golang.org/ref/spec#The_zero_value" target="_blank" rel="noopener">zero value</a> 是 go 中变量在声明之后但是未初始化被赋予的该类型的一个默认值。</p><blockquote><p>正确理解 nil 是正确理解 go 中类型的重要一环，因而 nil 的任何细节在遇到之后都不要错过，要做到相应的记录。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;golang 中的 nil 是不同于其他语言的，为了更好的理解 nil，在此我将尝试一步一步揭示 nil 在 golang 中的一些操作和现象。&lt;/p&gt;
&lt;h2 id=&quot;1-nil-是不能比较的&quot;&gt;&lt;a href=&quot;#1-nil-是不能比较的&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="basic" scheme="http://wecatch.me/go/categories/basic/"/>
    
    
      <category term="nil" scheme="http://wecatch.me/go/tags/nil/"/>
    
  </entry>
  
</feed>
