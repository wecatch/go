<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Go goroutine 和 channel 详解 (二) ：channel · Go Tutorial</title><meta name="description" content="Go goroutine 和 channel 详解 (二) ：channel - wecatch"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/go/favicon.ico"><link rel="stylesheet" href="/go/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://wecatch.me/go/atom.xml" title="Go Tutorial"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Go Tutorial</h2></a></div><a href="/go/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/go/categories/basic/" target="_self" class="li component-nav-item"><p>基础概念</p></a><a href="/go/categories/advanced/" target="_self" class="li component-nav-item"><p>高级主题</p></a><a href="/go/categories/practice/" target="_self" class="li component-nav-item"><p>最佳实践</p></a><a href="/go/book" target="_self" class="li component-nav-item"><p>书籍推荐</p></a><a href="/go/categories/projects/" target="_self" class="li component-nav-item"><p>开源项目</p></a></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Go goroutine 和 channel 详解 (二) ：channel</h1><div class="post-info">Dec 1, 2017</div><div class="post-content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果说 goroutine 是并发执行的一个 Go program， channel 就是它们之间的连接通道，它提供了 goroutine 之间相互通信的机制。Channel 是有类型的，channel 中使用的 type 称之为 element type，比如 int 类型的 channel 写作为 <code>chan int</code>。</p>
<p>Go 使用 make 内建函数创建 channel。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>同 map 一样，一个 channel 引用着 make 创建的底层数据结构上，当把 channel 当做函数参数传递时，实际上是拷贝一份 reference，也就是说函数内部和外部引用的是相同的数据结构，所以在函数内部可以直接修改 channel 的值。同其它 reference type 一样，<strong>channel 的 zero value 是 nil</strong>。</p>
<p><strong>Channel 是可比较的，如果两个 channel 的类型相同，它们可以彼此相互比较</strong>，当然 channel 也可以和 nil 比较。</p>
<h1 id="基本操作-send、receive、close"><a href="#基本操作-send、receive、close" class="headerlink" title="基本操作: send、receive、close"></a>基本操作: send、receive、close</h1><p>Channel 有两种主要的操作：send 和 receive，综合来讲就是 communication。Go 使用 <code>&lt;-</code> 操作符来实现 send 和 receive。Send 操作 <code>&lt;-</code> 在 channel 右侧，receive 操作 <code>&lt;-</code> 在左侧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">//send</span></span><br><span class="line">x = &lt;- ch <span class="comment">//receive</span></span><br><span class="line">&lt;- ch <span class="comment">//receive</span></span><br></pre></td></tr></table></figure>
<p>Channel 还支持第三种操作 <code>close</code>，如果 channel 被 close，表明 channel 不会再 send 任何值了，如果还继续对 channel 执行 receive 操作，等 channel 中的值消耗完毕之后，之后返回的是对应 element type 的 zero value，如果对 channel 执行 send 操作，将会引起 panic。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></p>
<h1 id="Unbuffered-channel"><a href="#Unbuffered-channel" class="headerlink" title="Unbuffered channel"></a>Unbuffered channel</h1><p>在创建 channel 时可以指定 channel 的容量，如果不指定默认是 0，我们称这种 channel 是 unbuffered channel。</p>
<p>如果在一个 goroutine 中对 unbuffered channel 执行 send 操作将会一直阻塞，直到有另一个不同的 goroutine 对同样的 channel 开始执行 receive 为止，此时通过 channel send 的值会发送到接收端，之后两个 goroutine 才会各自继续执行。</p>
<p>相似地，如果是 receive 操作先执行，也是类似的过程。</p>
<p><strong>正是因为 unbuffered channel 的这种特性，unbuffered channel 也称之为 synchronous channel</strong>。</p>
<h1 id="Channel-实践之一：synchronous"><a href="#Channel-实践之一：synchronous" class="headerlink" title="Channel 实践之一：synchronous"></a>Channel 实践之一：synchronous</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        c &lt;- <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine finish "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了利用 unbuffered channel 完成同步的能力，main goroutine 会一直等待直到满足特定条件时才会结束。</p>
<h1 id="Channel-的实践之二：pipeline"><a href="#Channel-的实践之二：pipeline" class="headerlink" title="Channel 的实践之二：pipeline"></a>Channel 的实践之二：pipeline</h1><p>Channel 是用来连接 goroutine 的通道，借此通道可以达到一个 goroutine 负责输入，另一个 goroutine 负责输出，这样的形式称之为 pipeline。</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/WX20171229-170322.png" alt="pipeline"></p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/go/posts/go-goroutine-channel-1/" class="prev">上一篇</a><a href="/go/posts/go-interface-4/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://wecatch.me/go">wecatch</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p><p>本站文章遵循 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">Creative Commons BY-NC-ND 4.0（自由转载-保持署名-非商用-禁止演绎）</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-79591400-1",'auto');ga('send','pageview');</script></body></html>