<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Go interface 详解(二) ：定义和使用 · Go Tutorial</title><meta name="description" content="Go interface 详解(二) ：定义和使用 - wecatch"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/go/favicon.ico"><link rel="stylesheet" href="/go/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://wecatch.me/go/atom.xml" title="Go Tutorial"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Go Tutorial</h2></a></div><a href="/go/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/go/categories/basic/" target="_self" class="li component-nav-item"><p>基础概念</p></a><a href="/go/categories/advanced/" target="_self" class="li component-nav-item"><p>高级主题</p></a><a href="/go/categories/practice/" target="_self" class="li component-nav-item"><p>最佳实践</p></a><a href="/go/book" target="_self" class="li component-nav-item"><p>书籍推荐</p></a><a href="/go/categories/projects/" target="_self" class="li component-nav-item"><p>开源项目</p></a></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Go interface 详解(二) ：定义和使用</h1><div class="post-info">Oct 12, 2017</div><div class="post-content"><blockquote>
<p>本系列是阅读 “The Go Programming Language” 理解和记录。</p>
</blockquote>
<h1 id="定义-interface"><a href="#定义-interface" class="headerlink" title="定义 interface"></a>定义 interface</h1><p>正如上文所说，Go interface 是一种类型，一个 interface type 指定了一组 method 集合，如果说一个 concrete type 是一个 interface 的 instance，我们说这个 concrete type 实现了这个 interface 的所有方法。</p>
<p>在 Go 的标准库 <code>io</code> package 中定义了很多有用的 interface：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Reader</code> 代表任何可以去读 byte 的类型，类似的，<code>Writer</code> 代表任何可以写入 byte 的类型，<code>Closer</code> 代表任何可以执行 close 的类型。除此之外，我们还能在 io package 中发现其它<strong>组合式的 interface</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ReaderWrite</code> 和 <code>ReadWriteCloser</code> 的语法形式和 struct 的 embedding 非常类似，被称为 <code>embedding interface</code>，通过这种形式可以便捷的实现一个新的 interface 而不必写出 interface 包含的所有 method。</p>
<p>注意 Go 标准库中对组合 interface 的命名，你应该总是遵循这样的规则。</p>
<p><code>ReaderWrite</code> 也可以用非 embedding 的形式实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者是二者的组合：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n intm err error)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的几种实现都是等价的，但是我们更推崇使用 embedding 的形式。</p>
<p>说完了 interface type 的定义，再说说 interface type 使用。</p>
<h1 id="实现-interface-并使用"><a href="#实现-interface-并使用" class="headerlink" title="实现 interface 并使用"></a>实现 interface 并使用</h1><p>如果一个 concrete type 实现了某个 interface type，其值可以赋值给 interface type 的 instance。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(<span class="keyword">byte</span>.Buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwc io.ReadWriteCloser</span><br><span class="line">rwc = os.Stdout</span><br></pre></td></tr></table></figure></p>
<p>甚至赋值符号右边也可以是 interface instance，只要它们的关系满足<strong>左边 interface type method 集合是右边 interface type method 集合的子集</strong>即可：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = rwc</span><br></pre></td></tr></table></figure></p>
<p><code>w</code> method 集合 <code>{Writer}</code> 是 <code>rwc</code> method 集合 <code>{Reader, Writer, Closer}</code> 的子集。</p>
<p>在 Struct 中，在一个类型 T 上直接调用 receiver 是 <code>*T</code> 的 method 是合法的，只要 T 是以 variable 的形势存在，看个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样是可以的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">t.String()</span><br></pre></td></tr></table></figure></p>
<p>但是这样不行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&#123;&#125;.String()</span><br></pre></td></tr></table></figure></p>
<p>Struct 这个微妙的细节也体现在 interface 的赋值上，只有 <code>*T</code> 实现了 <code>String</code> 所以 <code>*T</code> 才能满足 interface <code>Stringer</code>，这样是可以的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ fmt.Stringer = &amp;t</span><br></pre></td></tr></table></figure></p>
<p>但是这样是不行的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T does not implement fmt.Stringer (String method has pointer)</span></span><br><span class="line"><span class="keyword">var</span> _ fmt.Stringer = t</span><br></pre></td></tr></table></figure></p>
<p>这也是<a href="http://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="noopener">理解 go interface 的 5 个关键点</a>第5点所讲到的。</p>
<p>虽然 interface type 和 concrete type 之间的关系是隐式的 implicitly，但是在某些情况下显式地声明 concrete type 和 interface 的关系则很有用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p>
<p><code>new(bytes.Buffer)</code> 返回 <code>bytes.Buffer</code> 的 pointer，这正是实现 <code>Writer</code> 需要的类型。</p>
<p>即使 <code>nil</code> 我们也可以显式地进行转换:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="Empty-interface"><a href="#Empty-interface" class="headerlink" title="Empty interface"></a>Empty interface</h1><p>还有一种很重要的 interface 需要我们注意：<strong>interface{}</strong>，empty interface 没有任何 method。</p>
<p>Method 集合是 interface type 和 concrete type 之间关系的契约，也就是说 interface 向 concrete type 提出了要求说，你必须提供我要求的这些方法才能使用我，但是 empty interface 没有提供任何方法是不是不需要任何方法就可以使用它？的确如此。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p>
<p>Empty interface 可以让任何类型赋值，但是它没有任何方法该如何真正使用它？这就涉及到 type assertion ，从 <code>interface{}</code> 获取真正有用的 concrete value，后面我们会讲到。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go interface 提供了在抽象层的组合和使用，只要你愿意你总是能找到一种方法可以在不修改已有包代码的情况下组合使用包中提供的任何功能。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/go/posts/go-interface-3/" class="prev">PREV</a><a href="/go/posts/go-interface-1/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://wecatch.me/go">wecatch</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-79591400-1",'auto');ga('send','pageview');</script></body></html>